package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	// Find all generated protobuf packages
	err := filepath.Walk("gen", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		
		if strings.HasSuffix(path, ".pb.go") {
			packageDir := filepath.Dir(path)
			packageName := filepath.Base(packageDir)
			
			// Parse the .pb.go file to find enum types
			enums, err := findEnumTypes(path)
			if err != nil {
				return fmt.Errorf("parsing %s: %w", path, err)
			}
			
			if len(enums) > 0 {
				err = generateMarshalFile(packageDir, packageName, enums)
				if err != nil {
					return fmt.Errorf("generating marshal file for %s: %w", packageDir, err)
				}
				log.Printf("Generated marshal.go for package %s with %d enums", packageName, len(enums))
			}
		}
		
		return nil
	})
	
	if err != nil {
		log.Fatalf("Error: %v", err)
	}
}

// findEnumTypes parses a .pb.go file and extracts enum type information
func findEnumTypes(filename string) ([]EnumInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}
	
	var enums []EnumInfo
	
	// Look for enum type definitions and their constants
	for _, decl := range node.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			if d.Tok == token.TYPE {
				for _, spec := range d.Specs {
					if ts, ok := spec.(*ast.TypeSpec); ok {
						if ident, ok := ts.Type.(*ast.Ident); ok && ident.Name == "int32" {
							// Found an enum type - now find its constants
							enumName := ts.Name.Name
							constants := findEnumConstants(node, enumName)
							if len(constants) > 0 {
								enums = append(enums, EnumInfo{
									Name:      enumName,
									Constants: constants,
								})
							}
						}
					}
				}
			}
		}
	}
	
	return enums, nil
}

// findEnumConstants finds all constants for a given enum type
func findEnumConstants(node *ast.File, enumTypeName string) []string {
	var constants []string
	
	for _, decl := range node.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.CONST {
			for _, spec := range genDecl.Specs {
				if valueSpec, ok := spec.(*ast.ValueSpec); ok {
					// Check if this constant is of our enum type
					if ident, ok := valueSpec.Type.(*ast.Ident); ok && ident.Name == enumTypeName {
						for _, name := range valueSpec.Names {
							constants = append(constants, name.Name)
						}
					}
				}
			}
		}
	}
	
	return constants
}

type EnumInfo struct {
	Name      string
	Constants []string
}

// generateMarshalFile creates a marshal.go file with XMLEnum wrappers and parsers
func generateMarshalFile(packageDir, packageName string, enums []EnumInfo) error {
	content := generateMarshalContent(packageName, enums)
	
	marshalPath := filepath.Join(packageDir, "marshal.go")
	return os.WriteFile(marshalPath, []byte(content), 0644)
}

// generateMarshalContent creates the content for marshal.go
func generateMarshalContent(packageName string, enums []EnumInfo) string {
	var sb strings.Builder
	
	// Package header
	sb.WriteString(fmt.Sprintf("// Code generated by generate-marshals. DO NOT EDIT.\n\n"))
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	sb.WriteString("import \"strings\"\n\n")
	
	// Generate String() methods and parsers for each enum
	// These allow developers to use type-safe enum constants with string fields
	for _, enum := range enums {
		sb.WriteString(generateEnumStringMethod(enum))
		sb.WriteString("\n\n")
		sb.WriteString(generateEnumParser(enum))
		sb.WriteString("\n\n")
	}
	
	return sb.String()
}

// generateEnumStringMethod creates a String() method for the enum type
func generateEnumStringMethod(enum EnumInfo) string {
	var sb strings.Builder
	
	sb.WriteString(fmt.Sprintf("// XMLString returns the XML string representation of %s\n", enum.Name))
	sb.WriteString(fmt.Sprintf("func (e %s) XMLString() string {\n", enum.Name))
	sb.WriteString("\tswitch e {\n")
	
	// Generate cases for each constant
	for _, constant := range enum.Constants {
		if strings.HasSuffix(constant, "_UNSPECIFIED") {
			continue // Skip UNSPECIFIED values
		}
		
		// Extract the meaningful part of the constant name
		upperName := strings.ToUpper(enum.Name)
		idx := strings.LastIndex(constant, upperName+"_")
		if idx >= 0 {
			afterPrefix := constant[idx+len(upperName)+1:]
			if afterPrefix != "" && afterPrefix != "UNSPECIFIED" {
				sb.WriteString(fmt.Sprintf("\tcase %s:\n", constant))
				sb.WriteString(fmt.Sprintf("\t\treturn \"%s\"\n", afterPrefix))
			}
		}
	}
	
	sb.WriteString("\tdefault:\n")
	sb.WriteString("\t\treturn \"\"\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}")
	
	return sb.String()
}

// generateEnumParser creates the parser function for an enum
func generateEnumParser(enum EnumInfo) string {
	var sb strings.Builder
	
	sb.WriteString(fmt.Sprintf("// Parse%sString parses a string value to %s enum (case-insensitive)\n", enum.Name, enum.Name))
	sb.WriteString(fmt.Sprintf("func Parse%sString(s string) (%s, bool) {\n", enum.Name, enum.Name))
	sb.WriteString("\ts = strings.ToUpper(s)\n")
	sb.WriteString("\tswitch s {\n")
	
	// Generate cases for each constant
	for _, constant := range enum.Constants {
		if strings.HasSuffix(constant, "_UNSPECIFIED") {
			continue // Skip UNSPECIFIED values
		}
		
		// Extract the meaningful part of the constant name
		// Try to find the enum pattern: EnumName_ENUM_NAME_VALUE
		// We'll look for the last occurrence of the enum name in uppercase
		upperName := strings.ToUpper(enum.Name)
		
		// Find the pattern EnumName_..._VALUE
		idx := strings.LastIndex(constant, upperName+"_")
		if idx >= 0 {
			// Skip past "EnumName_..._" to get the value part
			afterPrefix := constant[idx+len(upperName)+1:]
			if afterPrefix != "" && afterPrefix != "UNSPECIFIED" {
				sb.WriteString(fmt.Sprintf("\tcase \"%s\":\n", afterPrefix))
				sb.WriteString(fmt.Sprintf("\t\treturn %s, true\n", constant))
			}
		}
	}
	
	sb.WriteString("\tdefault:\n")
	sb.WriteString(fmt.Sprintf("\t\treturn %s(0), false\n", enum.Name))
	sb.WriteString("\t}\n")
	sb.WriteString("}")
	
	return sb.String()
}

// generateEnumToString creates the enum-to-string function for marshaling
func generateEnumToString(enum EnumInfo) string {
	var sb strings.Builder
	
	sb.WriteString(fmt.Sprintf("// enum%sToString converts %s enum to its XML string representation\n", enum.Name, enum.Name))
	sb.WriteString(fmt.Sprintf("func enum%sToString(e %s) string {\n", enum.Name, enum.Name))
	sb.WriteString("\tswitch e {\n")
	
	// Generate cases for each constant
	for _, constant := range enum.Constants {
		if strings.HasSuffix(constant, "_UNSPECIFIED") {
			continue // Skip UNSPECIFIED values
		}
		
		// Extract the meaningful part of the constant name
		upperName := strings.ToUpper(enum.Name)
		idx := strings.LastIndex(constant, upperName+"_")
		if idx >= 0 {
			afterPrefix := constant[idx+len(upperName)+1:]
			if afterPrefix != "" && afterPrefix != "UNSPECIFIED" {
				sb.WriteString(fmt.Sprintf("\tcase %s:\n", constant))
				sb.WriteString(fmt.Sprintf("\t\treturn \"%s\"\n", afterPrefix))
			}
		}
	}
	
	sb.WriteString("\tdefault:\n")
	sb.WriteString("\t\treturn \"\"\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}")
	
	return sb.String()
}